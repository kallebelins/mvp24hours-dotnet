# Command Idempotency

## Overview

Idempotency ensures that an operation can be executed multiple times without changing the result beyond the initial execution. This is essential for distributed systems where retries and duplications can occur.

## Why Idempotency?

```
┌──────────────────────────────────────────────────────────────┐
│                    Duplication Scenarios                      │
├──────────────────────────────────────────────────────────────┤
│  1. Network timeout → Client retries                         │
│  2. 500 error → Client resends                               │
│  3. Message broker → Message redelivery                      │
│  4. Failover → Duplicate processing                          │
└──────────────────────────────────────────────────────────────┘
```

## Implementation

### IIdempotentCommand Interface

```csharp
public interface IIdempotentCommand
{
    string? IdempotencyKey { get; }
}
```

### Idempotent Command

```csharp
public record CreateOrderCommand : IMediatorCommand<OrderDto>, IIdempotentCommand
{
    public required string CustomerEmail { get; init; }
    public required List<OrderItemDto> Items { get; init; }
    
    // Key generated by client
    public string? IdempotencyKey { get; init; }
}
```

### IdempotencyBehavior

```csharp
public sealed class IdempotencyBehavior<TRequest, TResponse>
    : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IIdempotentCommand
{
    private readonly IDistributedCache _cache;
    private readonly IIdempotencyKeyGenerator _keyGenerator;
    private readonly MediatorOptions _options;

    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken)
    {
        var key = request.IdempotencyKey 
            ?? _keyGenerator.Generate(request);
        
        var cacheKey = $"idempotency:{key}";
        
        // Check if already processed
        var cached = await _cache.GetStringAsync(cacheKey, cancellationToken);
        if (cached is not null)
        {
            return JsonSerializer.Deserialize<TResponse>(cached)!;
        }

        // Process and store result
        var result = await next();

        var options = new DistributedCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = 
                TimeSpan.FromHours(_options.IdempotencyDurationHours)
        };

        await _cache.SetStringAsync(
            cacheKey,
            JsonSerializer.Serialize(result),
            options,
            cancellationToken);

        return result;
    }
}
```

## Key Generation

### IIdempotencyKeyGenerator

```csharp
public interface IIdempotencyKeyGenerator
{
    string Generate<TRequest>(TRequest request);
}
```

### DefaultIdempotencyKeyGenerator

```csharp
public class DefaultIdempotencyKeyGenerator : IIdempotencyKeyGenerator
{
    public string Generate<TRequest>(TRequest request)
    {
        var json = JsonSerializer.Serialize(request);
        var hash = SHA256.HashData(Encoding.UTF8.GetBytes(json));
        return Convert.ToBase64String(hash);
    }
}
```

### Custom Key

```csharp
public record ProcessPaymentCommand : IMediatorCommand<PaymentResult>, IIdempotentCommand
{
    public required Guid OrderId { get; init; }
    public required decimal Amount { get; init; }
    
    // Key based on OrderId to ensure one payment per order
    public string? IdempotencyKey => $"payment:{OrderId}";
}
```

## Configuration

```csharp
// With in-memory cache
services.AddMediatorMemoryCache();

// Or with Redis (recommended for production)
services.AddMediatorRedisCache("localhost:6379");

services.AddMvpMediator(options =>
{
    options.RegisterHandlersFromAssemblyContaining<Program>();
    options.RegisterIdempotencyBehavior = true;
    options.IdempotencyDurationHours = 24; // Default
});
```

## Execution Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                    IdempotencyBehavior                           │
├─────────────────────────────────────────────────────────────────┤
│  1. Extract/generate IdempotencyKey                             │
│  2. Check cache: "idempotency:{key}"                            │
│     ├── HIT  → Return cached result                             │
│     └── MISS → Continue processing                              │
│  3. Execute handler                                             │
│  4. Store result in cache                                       │
│  5. Return result                                               │
└─────────────────────────────────────────────────────────────────┘
```

## Key Strategies

### By User + Operation

```csharp
public string? IdempotencyKey => $"user:{UserId}:order:{DateTime.Today:yyyyMMdd}";
```

### By Request ID (from client)

```csharp
// Client sends header X-Idempotency-Key
[HttpPost]
public async Task<ActionResult<OrderDto>> Create(
    CreateOrderCommand command,
    [FromHeader(Name = "X-Idempotency-Key")] string? idempotencyKey)
{
    var commandWithKey = command with { IdempotencyKey = idempotencyKey };
    var result = await _mediator.SendAsync(commandWithKey);
    return Ok(result);
}
```

### By Content Hash

```csharp
public string? IdempotencyKey => null; // Uses DefaultIdempotencyKeyGenerator
```

## Best Practices

1. **Appropriate TTL**: Configure duration based on use case
2. **Semantic Keys**: Use keys that make sense for the domain
3. **Redis in Production**: Use Redis for distributed environments
4. **Client Generates Key**: Allow client to provide the key
5. **Logging**: Log when operations are deduplicated
6. **Monitoring**: Monitor duplication rate

